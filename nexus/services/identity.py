"""
Identity Service for NEXUS.

This service manages user identities and provides the "gatekeeper" functionality
for the sovereign personalization architecture. It determines whether a user
is a "visitor" (unregistered) or "member" (registered) based on their public_key.

Key responsibilities:
- Identity retrieval: Get identity by public_key to distinguish visitors from members
- Identity creation: Create new identities with empty config/prompt overrides
- Get-or-create pattern: Convenience method for identity initialization
- User profile management: Retrieve structured user_profile with config_overrides
  and prompt_overrides for downstream personalization
- Config updates: Update user configuration overrides (model, temperature, max_tokens)
- Prompt updates: Update user prompt overrides (persona, system, tools)

Sovereign personalization architecture:
Each user's identity document contains:
- public_key: Ethereum-style public key (user identity)
- config_overrides: User-specific LLM configuration (overrides system defaults)
- prompt_overrides: User-specific prompt customizations (persona, system, tools)
- created_at: Identity creation timestamp

The IdentityService acts as the gatekeeper by providing identity verification
to OrchestratorService, which halts unregistered visitors and injects user_profile
into Run metadata for registered members.
"""

import asyncio
import logging
from datetime import UTC, datetime
from typing import Any

from nexus.services.database.service import DatabaseService

logger = logging.getLogger(__name__)

# Note: Prompt modules are now dynamically read from config.
# In v2 architecture, only 'friends_profile' is stored in config.
# CORE_IDENTITY and other context blocks are generated by ContextBuilder.


class IdentityService:
    """Service for managing user identities in the sovereign personalization system.

    This service acts as the gatekeeper between "visitor" and "member" states,
    providing identity verification and creation capabilities.
    """

    def __init__(self, db_service: DatabaseService):
        """Initialize IdentityService.

        Args:
            db_service: DatabaseService instance for identity persistence
        """
        self.db_service = db_service
        logger.info("IdentityService initialized")

    async def get_identity(self, public_key: str) -> dict[str, Any] | None:
        """Retrieve an identity by its public key.

        Args:
            public_key: The public key to search for

        Returns:
            Optional[Dict[str, Any]]: Identity document if found, None otherwise
        """
        logger.debug(f"Retrieving identity for public_key={public_key}")

        if not self.db_service.provider:
            logger.error("Database provider not initialized")
            return None

        # Call database service in thread pool (it's synchronous)
        identity = await asyncio.to_thread(
            self.db_service.provider.find_identity_by_public_key, public_key
        )

        if identity:
            logger.info(f"Identity found for public_key={public_key}")
        else:
            logger.debug(f"No identity found for public_key={public_key}")

        return identity

    async def create_identity(
        self, public_key: str, metadata: dict[str, Any] | None = None
    ) -> bool:
        """Create a new identity.

        Args:
            public_key: The public key for the new identity
            metadata: Optional metadata to attach to the identity

        Returns:
            bool: True if creation was successful, False otherwise
        """
        logger.info(f"Creating new identity for public_key={public_key}")

        if not self.db_service.provider:
            logger.error("Database provider not initialized")
            return False

        identity_data = {
            "public_key": public_key,
            "created_at": datetime.now(UTC),
            "metadata": metadata or {},
            "config_overrides": {},
            "prompt_overrides": {},
            "turn_count": 0,
        }

        # Call database service in thread pool (it's synchronous)
        success = await asyncio.to_thread(
            self.db_service.provider.create_identity, identity_data
        )

        if success:
            logger.info(f"Successfully created identity for public_key={public_key}")
        else:
            logger.error(f"Failed to create identity for public_key={public_key}")

        return success

    async def get_or_create_identity(self, public_key: str) -> dict[str, Any] | None:
        """Get an existing identity or create a new one if it doesn't exist.

        This is a convenience method that combines get and create operations.

        Args:
            public_key: The public key to search for or create

        Returns:
            Optional[Dict[str, Any]]: Identity document, or None if creation failed.
                                    Contains '_just_created' flag if newly created.
        """
        logger.debug(f"Get or create identity for public_key={public_key}")

        # Try to get existing identity
        identity = await self.get_identity(public_key)

        if identity:
            logger.debug(f"Found existing identity for public_key={public_key}")
            return identity

        # Create new identity
        logger.info(
            f"Identity not found, creating new identity for public_key={public_key}"
        )
        success = await self.create_identity(public_key)

        if not success:
            logger.error(f"Failed to create identity for public_key={public_key}")
            return None

        # Retrieve the newly created identity
        new_identity = await self.get_identity(public_key)
        if new_identity:
            # Add marker to indicate this was just created
            new_identity["_just_created"] = True
        return new_identity

    async def get_user_profile(self, public_key: str) -> dict[str, Any]:
        """Get user profile including overrides.

        This is the primary method for retrieving a user's personalization settings.
        Returns a structured user_profile dict containing config_overrides and prompt_overrides.

        Args:
            public_key: The user's public key

        Returns:
            Dict containing user_profile with overrides, or minimal profile if not found
        """
        logger.debug(f"Retrieving user profile for public_key={public_key}")

        identity = await self.get_identity(public_key)

        if not identity:
            logger.warning(
                f"No identity found for public_key={public_key}, returning minimal profile"
            )
            return {
                "public_key": public_key,
                "config_overrides": {},
                "prompt_overrides": {},
                "created_at": None,
            }

        # Extract user profile from identity document
        user_profile = {
            "public_key": identity["public_key"],
            "config_overrides": identity.get("config_overrides", {}),
            "prompt_overrides": identity.get("prompt_overrides", {}),
            "created_at": identity.get("created_at"),
        }

        logger.info(f"User profile retrieved for public_key={public_key}")
        return user_profile

    async def update_user_config(
        self, public_key: str, config_overrides: dict[str, Any]
    ) -> bool:
        """Update user configuration overrides.

        Args:
            public_key: The user's public key
            config_overrides: Dict of config values to override (model, temperature, etc.)

        Returns:
            bool: True if update was successful, False otherwise
        """
        logger.info(f"Updating config overrides for public_key={public_key}")

        if not self.db_service.provider:
            logger.error("Database provider not initialized")
            return False

        success = await asyncio.to_thread(
            self.db_service.provider.update_identity_field,
            public_key,
            "config_overrides",
            config_overrides,
        )

        if success:
            logger.info(
                f"Successfully updated config_overrides for public_key={public_key}"
            )
        else:
            logger.error(
                f"Failed to update config_overrides for public_key={public_key}"
            )

        return success

    async def update_user_prompts(
        self, public_key: str, prompt_overrides: dict[str, str]
    ) -> bool:
        """Update user prompt overrides.

        Args:
            public_key: The user's public key
            prompt_overrides: Dict of prompt keys to override (persona, system, tools, etc.)

        Returns:
            bool: True if update was successful, False otherwise
        """
        logger.info(f"Updating prompt overrides for public_key={public_key}")

        if not self.db_service.provider:
            logger.error("Database provider not initialized")
            return False

        success = await asyncio.to_thread(
            self.db_service.provider.update_identity_field,
            public_key,
            "prompt_overrides",
            prompt_overrides,
        )

        if success:
            logger.info(
                f"Successfully updated prompt_overrides for public_key={public_key}"
            )
        else:
            logger.error(
                f"Failed to update prompt_overrides for public_key={public_key}"
            )

        return success

    async def get_effective_profile(
        self, public_key: str, config_service
    ) -> dict[str, Any]:
        """Get user's effective configuration profile (merged genesis template + user overrides).

        This method implements the configuration composition logic as part of the
        "Information Expert" principle - IdentityService knows about user-specific
        overrides and is responsible for merging them with system defaults.

        Args:
            public_key: The user's public key
            config_service: ConfigService instance for accessing genesis template

        Returns:
            Dict containing:
                - effective_config: Merged configuration (defaults + user overrides)
                - effective_prompts: Merged prompts (defaults + user overrides)
                - user_overrides: Original user overrides (config + prompts)
                - editable_fields: List of fields that can be edited via UI
                - field_options: UI metadata for field rendering
        """
        logger.debug(f"Composing effective profile for public_key={public_key}")

        # Step 1: Get genesis template (system defaults)
        user_defaults = config_service.get_user_defaults()
        default_config = user_defaults.get("config", {})
        default_prompts = user_defaults.get("prompts", {})

        # Step 2: Get user-specific overrides
        user_profile = await self.get_user_profile(public_key)
        config_overrides = user_profile.get("config_overrides", {})
        prompt_overrides = user_profile.get("prompt_overrides", {})

        # Step 3: Compose effective config (user overrides take precedence)
        effective_config = {**default_config, **config_overrides}

        # Step 4: Compose effective prompts with metadata (content, editable)
        # In v2 architecture, prompts are dynamically read from config
        # (typically only 'friends_profile' for user personalization)
        effective_prompts = {}
        for key, default_prompt in default_prompts.items():
            # User override: replace content, but inherit editable from defaults
            if key in prompt_overrides:
                # User provided new content, but keep editable from defaults
                effective_prompts[key] = {
                    "content": prompt_overrides[key],  # User's custom content
                    "editable": default_prompt.get("editable", False)
                    if isinstance(default_prompt, dict)
                    else False,
                }
            else:
                # Use default prompt with full structure
                if isinstance(default_prompt, dict):
                    effective_prompts[key] = {
                        "content": default_prompt.get("content", ""),
                        "editable": default_prompt.get("editable", False),
                    }
                else:
                    # Backward compatibility: if default is string
                    effective_prompts[key] = {
                        "content": default_prompt
                        if isinstance(default_prompt, str)
                        else "",
                        "editable": False,
                    }

        # Step 5: Extract UI metadata and dynamically generate model options
        genesis_template = config_service.get_genesis_template()
        ui_config = genesis_template.get("ui", {})
        editable_fields = ui_config.get("editable_fields", [])
        field_options = ui_config.get(
            "field_options", {}
        ).copy()  # Make a copy to avoid modifying original

        # Dynamically generate model options from llm.catalog
        llm_catalog = genesis_template.get("llm", {}).get("catalog", {})
        model_aliases: list[str] = []
        for model_key, model_meta in llm_catalog.items():
            # Prefer aliases if available, otherwise use the catalog key itself
            aliases = (
                model_meta.get("aliases", []) if isinstance(model_meta, dict) else []
            )
            if aliases:
                model_aliases.extend(aliases)
            else:
                # Fallback: use catalog key if no aliases defined
                model_aliases.append(model_key)

        # Update field_options for model field with dynamic options
        if "config.model" in field_options and model_aliases:
            field_options["config.model"]["options"] = sorted(
                set(model_aliases)
            )  # Remove duplicates and sort
            logger.debug(
                f"Dynamically generated {len(model_aliases)} model options for UI"
            )

        # Compose final profile
        effective_profile = {
            "effective_config": effective_config,
            "effective_prompts": effective_prompts,
            "user_overrides": {
                "config_overrides": config_overrides,
                "prompt_overrides": prompt_overrides,
            },
            "editable_fields": editable_fields,
            "field_options": field_options,
        }

        logger.info(f"Effective profile composed for public_key={public_key}")
        return effective_profile

    async def delete_identity(self, public_key: str) -> bool:
        """Delete an identity from the database.

        This is typically called when a user wants to permanently remove their identity.

        Args:
            public_key: The user's public key

        Returns:
            bool: True if deletion was successful, False otherwise
        """
        logger.info(f"Deleting identity for public_key={public_key}")

        if not self.db_service.provider:
            logger.error("Database provider not initialized")
            return False

        success = await asyncio.to_thread(
            self.db_service.provider.delete_identity, public_key
        )

        if success:
            logger.info(f"Successfully deleted identity for public_key={public_key}")
        else:
            logger.warning(
                f"Failed to delete identity (may not exist) for public_key={public_key}"
            )

        return success
