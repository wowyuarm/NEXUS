# Context Architecture: Multi-Message [TAG] Structure

**Version:** 2.0  
**Date:** 2025-12-10  
**Status:** Active

---

## Overview

NEXUS context building has been refactored from a single concatenated system prompt to a **multi-message architecture** that better reflects the philosophical vision of NEXUS as a "dialogue space" where AI acts as a friend.

### Key Changes

| Aspect | v1 (Old) | v2 (New) |
|--------|----------|---------|
| **Message Structure** | 1 system + N history messages | 1 system + 4 user messages with [TAG] blocks |
| **System Prompt** | 4 concatenated layers (field, presence, capabilities, learning) | Single CORE_IDENTITY in code |
| **Prompt Location** | Files + database | Code + database |
| **Capabilities** | Loaded from files | Dynamically generated from ToolRegistry |
| **History** | Raw messages | Formatted [SHARED_MEMORY] block |
| **User Profile** | learning prompt layer | [FRIENDS_INFO] block |

---

## Message Structure

The LLM receives exactly 5 messages in this sequence:

### 1. System Message: CORE_IDENTITY

```
{
  "role": "system",
  "content": "# You are Nexus\n\nNexus is a dialogue space linking human and AI..."
}
```

**Purpose:** Establish NEXUS's essence, philosophy, and way of being.

**Content:** ~200 lines English prompt covering:
- Identity: NEXUS as a friend, not servant
- Space: Dialogue as shared field for co-growth
- Principles: Listening, presence, adaptation, honesty
- Context: Explanation of [TAG] blocks that follow
- Language: Respond in the language of `<human_input>`

**Location:** `nexus/services/context/prompts.py` (embedded constant)

**Stability:** Highly stable, cache-friendly (same for all users)

---

### 2. User Message: [CAPABILITIES]

```
{
  "role": "user",
  "content": "[CAPABILITIES]\nAvailable tools in this conversation:\n\n### web_search\nSearch the web for information\nParameters:\n- query (string, required): The search query\n..."
}
```

**Purpose:** Inform AI of available tools and their usage.

**Content:** Dynamically generated from `ToolRegistry.get_all_tool_definitions()`:
- Tool names and descriptions
- Parameter names, types, descriptions
- Required vs optional parameters

**Location:** Generated by `PromptManager.get_capabilities_prompt()`

**Stability:** Changes when tools are registered/unregistered

---

### 3. User Message: [SHARED_MEMORY]

```
{
  "role": "user",
  "content": "[SHARED_MEMORY count=3]\nRecent conversation memory:\n\n[2025-12-10 15:30] Human: Search for AI\n  Nexus: I'll search...\n[tool_use:web_search, query:AI development 2025]\nBased on search results..."
}
```

**Purpose:** Provide recent conversation history for context continuity.

**Format:**
```
[SHARED_MEMORY count=N]
Recent conversation memory:

[YYYY-MM-DD HH:MM] Human: message content
  Nexus: response content
[tool_use:web_search, query:search terms]
Additional AI response content...
...
```

**Time Display Optimization:** To save tokens, only human messages show timestamps. AI responses are indented with two spaces when they follow a human message, indicating they belong to the same conversational turn. If an AI message doesn't follow a human (e.g., first message is AI), it shows a timestamp.

**Key Behaviors:**
1. **Message Merging by run_id**: All AI messages within the same `run_id` are merged into a single logical response, preserving chronological order.
2. **Tool Call Annotation**: When tools are used, a `[tool_use:name, query:...]` annotation is inserted between the tool call declaration and the final response.
3. **Count Semantics**: The `count=N` reflects merged message count (human + merged AI), not the original message count.
4. **Filtering**: Excludes tool messages (role="tool") from the output.
5. **Truncation**: Long messages (>500 chars) are truncated with "..."
6. **Ordering**: Messages are displayed chronologically (oldest first).

**Content Processing:**
1. **Input**: Messages from `PersistenceService.get_history()` (newest first)
2. **Merging**: `MemoryFormatter._merge_messages_by_run_id()` groups messages by `run_id`:
   - Human messages: kept unchanged
   - AI messages within same `run_id`: merged chronologically
   - Tool call annotations extracted from `metadata.tool_calls`
3. **Formatting**: `MemoryFormatter.format_shared_memory()` applies limits after merging and formats output

**Annotation Format:**
- Single tool: `[tool_use:web_search, query:人工智能最新发展]`
- Multiple tools: `[tool_use:web_search, query:...; tool_use:calculator, expression:...]`
- Position: Inserted after the AI message where tool was declared, before subsequent AI responses

**Location:** Generated by `MemoryFormatter.format_shared_memory()`

**Stability:** Changes with each conversation turn

---

### 4. User Message: [FRIENDS_INFO]

```
{
  "role": "user",
  "content": "[FRIENDS_INFO]\nAbout this friend:\n\nI prefer concise, direct answers. I'm interested in AI ethics and philosophy."
}
```

**Purpose:** Provide user profile and preferences for personalization.

**Content:** From `identities.prompt_overrides.friends_profile`:
- User preferences and communication style
- Background and interests
- Any other context about the user
- Placeholder if no profile set

**Location:** Generated by `FriendsInfoFormatter.format_friends_info()`

**Stability:** Changes when user updates their profile

**Backward Compatibility:** Also reads legacy `learning` field if `friends_profile` not set

---

### 5. User Message: [THIS_MOMENT]

```
{
  "role": "user",
  "content": "[THIS_MOMENT]\n<current_time>2025-12-10 16:00:00+08:00</current_time>\n<human_input>\nWhat's the capital of France?\n</human_input>"
}
```

**Purpose:** Provide current input with timestamp context.

**Format:**
```
[THIS_MOMENT]
<current_time>YYYY-MM-DD HH:MM:SS±HH:MM</current_time>
<human_input>
User's current message
</human_input>
```

**Content:**
- Current time in user's timezone (calculated from UTC + offset)
- Human's current input text (may be multiline)

**Location:** Generated by `MomentFormatter.format_this_moment()`

**Stability:** Changes with each new input

---

## Architecture Components

### ContextBuilder

**File:** `nexus/services/context/builder.py`

Async service that orchestrates context building:

```python
class ContextBuilder:
    async def handle_build_request(self, message: Message) -> None:
        """Subscribe to CONTEXT_BUILD_REQUEST, build context, publish response"""
    
    async def build_context(
        self,
        owner_key: str,
        user_profile: Dict,
        current_input: str,
        timestamp_utc: str,
        timezone_offset: int
    ) -> List[Dict[str, str]]:
        """Build 5-message context list"""
```

**Bus Integration:**
- Subscribes to: `Topics.CONTEXT_BUILD_REQUEST`
- Publishes to: `Topics.CONTEXT_BUILD_RESPONSE`

**Dependencies:**
- `NexusBus` - Event bus
- `ToolRegistry` - Tool definitions
- `ConfigService` - Configuration
- `PersistenceService` - Message history

---

### PromptManager

**File:** `nexus/services/context/prompts.py`

Manages CORE_IDENTITY and capability descriptions:

```python
class PromptManager:
    def get_core_identity(self) -> str:
        """Return CORE_IDENTITY system prompt"""
    
    def get_capabilities_prompt(self, tool_definitions: List[Dict]) -> str:
        """Format [CAPABILITIES] block from tool definitions"""
```

**CORE_IDENTITY:** Embedded constant (~200 lines) defining NEXUS's essence

---

### Formatters

**File:** `nexus/services/context/formatters.py`

Three formatter classes for different context blocks. **MemoryFormatter** now includes message merging by `run_id` and tool call annotation:

```python
class MemoryFormatter:
    @staticmethod
    def format_shared_memory(history: List[Dict], limit: int = 20) -> str:
        """Format [SHARED_MEMORY] block with merged AI messages and tool annotations"""

    @staticmethod
    def _merge_messages_by_run_id(messages: List[Dict]) -> List[Dict]:
        """Merge AI messages by run_id and insert tool call annotations"""

    @staticmethod
    def _extract_tool_call_annotation(tool_calls: List) -> str:
        """Generate annotation string from tool_calls (e.g., [tool_use:web_search, query:...])"""

class FriendsInfoFormatter:
    @staticmethod
    def format_friends_info(user_profile: Dict) -> str:
        """Format [FRIENDS_INFO] block"""

class MomentFormatter:
    @staticmethod
    def format_this_moment(
        current_input: str,
        timestamp_utc: str,
        timezone_offset: int
    ) -> str:
        """Format [THIS_MOMENT] block"""
```

---

## Configuration

### config.example.yml

Simplified prompts section:

```yaml
user_defaults:
  prompts:
    friends_profile:
      content: ""
      editable: true
      description: "About this friend - preferences, patterns, and context"
```

**Note:** CORE_IDENTITY is no longer in config; it's in code.

### Database Initialization

Run `scripts/database_manager.py` → Option 8: Initialize configurations

**Changes:**
- No longer reads prompt files from `nexus/prompts/nexus/`
- Loads template from `config.example.yml`
- Creates/updates `configurations` collection

---

## Data Flow

```
1. OrchestratorService publishes CONTEXT_BUILD_REQUEST
   ├─ Run object with user_profile, current_input
   ├─ Metadata: client_timestamp_utc, client_timezone_offset

2. ContextBuilder.handle_build_request()
   ├─ Extract user_profile, current_input, timestamps
   ├─ Call build_context()
   │  ├─ Fetch history from PersistenceService
   │  ├─ Get tools from ToolRegistry
   │  ├─ Format 5 messages:
   │  │  1. system: CORE_IDENTITY
   │  │  2. user: [CAPABILITIES]
   │  │  3. user: [SHARED_MEMORY]
   │  │  4. user: [FRIENDS_INFO]
   │  │  5. user: [THIS_MOMENT]
   │  └─ Return message list
   └─ Publish CONTEXT_BUILD_RESPONSE

3. OrchestratorService receives response
   ├─ Extract messages and tools
   └─ Pass to LLMService for API call
```

---

## Design Rationale

### Why Multiple User Messages?

1. **Clarity:** Each [TAG] block has a clear semantic meaning
2. **Modularity:** Each block can be updated independently
3. **Alignment:** Mirrors how humans perceive context (capabilities, history, relationship, moment)
4. **Extensibility:** Easy to add new blocks (e.g., [MOOD], [CONSTRAINTS])

### Why CORE_IDENTITY in Code?

1. **Versioning:** Prompt changes tracked in git
2. **Consistency:** Same prompt for all environments
3. **Performance:** No file I/O during request
4. **Philosophy:** Prompt is part of the system's design, not configuration

### Why No Assistant Messages in First Call?

Per user specification: "First LLM API call will not include assistant content (historical memories combined in user role)"

This simplifies the context structure and aligns with the "dialogue space" philosophy where history is context, not prior turns.

---

## Migration from v1

### For Existing Users

1. **No action needed** - System handles backward compatibility
2. **Legacy `learning` field** still supported in `prompt_overrides`
3. **Old prompt files** archived in `.legacy/` directory

### For Developers

1. **Import change:**
   ```python
   # Old
   from nexus.services.context import ContextService
   
   # New
   from nexus.services.context import ContextBuilder
   ```

2. **Bus interface unchanged** - Same topics, same message structure

3. **Config structure simplified** - Only `friends_profile` in prompts

---

## Testing

### Unit Tests

Located in `tests/nexus/unit/services/context/`:

- `test_builder.py` - 11 tests for ContextBuilder
- `test_formatters.py` - 14 tests for formatters
- `test_prompts.py` - 11 tests for PromptManager

**Run:** `pytest tests/nexus/unit/services/context/ -v`

### Integration Testing

**Needed:** Live testing with Gemini API to verify multi-message structure works correctly

---

## Future Enhancements

1. **[MOOD] Block:** Detect and include user's emotional state
2. **[CONSTRAINTS] Block:** Include task-specific constraints
3. **Prompt Caching:** Leverage LLM provider caching for stable blocks
4. **Pattern Extraction:** LLM-based extraction of user patterns for [FRIENDS_INFO]
5. **Adaptive Limits:** Adjust history limit based on token budget

---

## References

- `nexus/services/context/` - Implementation
- `config.example.yml` - Configuration template
- `docs/tasks/25-1210_context-refactor.md` - Refactoring task details
- `docs/api_reference/02_CONFIGURATION_REFERENCE.md` - Configuration reference
